import { space, color } from "./config";
import theme, { themeType, themeValue } from "../theme";

export interface anyReactProps {
  [x: string]: unknown;
  sx?: {
    [x: string]: string;
  };
}

export type cssPropAndVar = [keyof themeValue, string];

interface stylePropsConfigItem {
  property: string;
  scale: string;
  transform?: Function;
}
export interface stylePropsConfigTyps {
  [x: string]: stylePropsConfigItem;
}

export function parseStyleProps(props: anyReactProps) {
  const styleProps: { [x: string]: string | number } = {};
  const forwardProps: { [x: string]: unknown } = {};
  const { sx, ...rest } = props;

  Object.entries(rest).forEach((entry: [string, unknown]) => {
    const [key, value] = entry;
    if (
      isStyleProp(key) &&
      (typeof value === "string" || typeof value === "number")
    ) {
      styleProps[key] = value;
    } else {
      forwardProps[key] = value;
    }
  });

  const stylePropsMapped = getMappedStyleProps(styleProps);
  const finalStyledPropsMapped = { ...stylePropsMapped, ...sx };

  return [finalStyledPropsMapped, forwardProps];
}

// The prop keys are already known to be valid prop keys
interface mappedStylePropsTypes {
  [x: string]: string;
}

const getMappedStyleProps = (styleProps: { [x: string]: string | number }) => {
  const mappedStyleProps: mappedStylePropsTypes = {};

  Object.entries(styleProps).forEach((entry) => {
    const [key, value] = entry;
    const [cssProperty, cssValue] = getStylePropCssVar(key, value);
    mappedStyleProps[cssProperty] = cssValue;
  });

  return mappedStyleProps;
};

const getAllStyleProps = (): stylePropsConfigTyps => {
  return {
    ...space,
    ...color,
  };
};

const isStyleProp = (propKey: string): Boolean => {
  const allStylePropKeys = Object.keys({
    ...space,
    ...color,
  });
  return allStylePropKeys.includes(propKey);
};

/**
 * Style Props tools
 *
 * covert {mb: "36"} to ['marginBottom', "var(--rh-space-36)"]
 * covert {color: "sprk.purple.deep"} to ['color', "var(--rh-colors-sprk_purple_dark)"]
 */
export function getStylePropCssVar(
  propKey: keyof stylePropsConfigTyps,
  propValue: string | number
): [keyof stylePropsConfigTyps, string] {
  const allStyleProps = getAllStyleProps();

  const isValueInTheme = isValidThemeValue(
    allStyleProps[propKey].scale,
    propValue
  );

  if (!isValueInTheme) {
    throwWarning("invalidThemeValue", [
      allStyleProps[propKey].scale,
      propValue,
    ]);
  }

  const CSSVarFunctionString = getCSSVarFunctionString(
    allStyleProps[propKey].scale,
    propValue
  );

  return [allStyleProps[propKey].property, CSSVarFunctionString];
}

/**
 * Theme CSS var tools
 */

/**
 * Validates that a given themeKey and themeValueKey are found within the theme
 */
export function isValidThemeValue(
  themeKey: keyof themeType,
  themeValueKey: keyof themeValue | unknown
): boolean {
  if (typeof themeValueKey !== "string" && typeof themeValueKey !== "number")
    return false;
  return Boolean(theme?.[themeKey]?.[themeValueKey]);
}

/**
 * Contains the "template" for generating CSS variables given a themeKey and themeValueKey
 * Returns a string
 */
export function getCSSVarName(
  themeKey: keyof themeType,
  themeValueKey: keyof themeValue
): false | string {
  if (!isValidThemeValue(themeKey, themeValueKey)) return false;
  return `--rh-${themeKey}-${themeValueKey}`.replace(/\./gi, "_");
}

/**
 * Returns a value from the theme given a themeKey and themeValueKey
 */
export function getThemeValue(
  themeKey: keyof themeType,
  themeValueKey: keyof themeValue
): false | string | number {
  if (!isValidThemeValue(themeKey, themeValueKey)) return false;
  const themeValue = theme[themeKey][themeValueKey];
  return themeValue;
}

/**
 * Returns a CSS value - using CSS var function
 */
export function getCSSVarFunctionString(
  themeKey: keyof themeType,
  themeValueKey: string | number
): string {
  const varName = getCSSVarName(themeKey, themeValueKey);
  return `var(${varName})`;
}

/**
 * Return a string representing a CSS property/value. (using CSS var function)
 */
export function getThemeRuleCSSVarString(
  themeKey: keyof themeType,
  themeValueKey: string
): false | string {
  if (!isValidThemeValue(themeKey, themeValueKey)) return false;

  const varName = getCSSVarName(themeKey, themeValueKey);
  const varValue = getThemeValue(themeKey, themeValueKey);

  return `${varName}: ${varValue};`;
}

/**
 * Returns an array of CSS variables generated by the theme
 */
export function getThemeCSSVars() {
  let cssVars = [];
  for (let themeKey in theme) {
    for (let themeValueKey in theme[themeKey]) {
      const rule = getThemeRuleCSSVarString(themeKey, themeValueKey);
      cssVars.push(rule);
    }
  }
  return cssVars;
}

/**
 * Playing around...
 */
const generateErrorMessage = (
  staticTags: TemplateStringsArray,
  ...tags: string[]
) => {
  let str = [staticTags[0]];
  for (let i = 0; i < tags.length; i++) {
    str.push(tags[i] + staticTags[i + 1]);
  }
  return str.join("");
};

/**
 * Error Messages
 */
interface getErrorMessagePropTypes {
  [x: string]: Function;
}

const getErrorMessage: getErrorMessagePropTypes = {
  invalidStyleProp: (values: string[]) => {
    const [styleProp] = values;
    return generateErrorMessage`Invalid style prop ${styleProp}.`;
  },
  invalidThemeValue: (values: string[]) => {
    const [themeScale, themeValue] = values;
    return generateErrorMessage`Theme value "${themeValue}" not found in "${themeScale}".`;
  },
};

const throwWarning = (
  errorType: keyof getErrorMessagePropTypes,
  values: (string | number)[]
) => {
  const message = getErrorMessage[errorType](values);
  console.warn(`WARNING: ${message}`);
};

/**
 * TODO: Add psuedo selectors
 *
 * @chakra-ui/styled-system/src/pseudos.ts
 */
